package net.agileframes.vr;

import javax.media.j3d.*;
import javax.vecmath.*;
import net.agileframes.forces.xyaspace.XYASpace;
import net.agileframes.core.forces.FuSpace;
import net.agileframes.core.vr.Body;

import net.agileframes.vr.BaseGeometry;
import com.objectspace.jgl.Array;
import net.agileframes.core.vr.Avatar;

public class XYAAvatar implements Avatar {
  private String name=null;
  private long counter=0;

  protected Body body = null;
  private Avatar parentAvatar = null;

  public int currentGeometryID;
  public int currentAppearanceID;

  protected BaseGeometry currentGeometry;
  protected Color3f currentAppearance;

  private BranchGroup topBG;
  private BranchGroup bottomBG;
  private BranchGroup behaviorBG=null;

  protected TransformGroup translateTG;// is used by AvatarQC-> needs to be public (herman)
  protected TransformGroup rotateTG;
  protected Switch geometrySwitchNode; // the different shapes are addes to this BranchGroup
  protected Transform3D t3dTranslation;
  protected Transform3D t3dRotation;
  protected RefreshBehavior refreshBehavior=null;

  protected Array geometryArray;
  protected Array appearanceArray;

  protected Vector3d vectorTranslation;
  protected Vector3d vectorRotation;

  protected Matrix3d matrixRotation;

  /**
   * Create a new instance of AvatarImplBase without any reference to a body, and therefore no refreshbehavior
   */
  public XYAAvatar() {
    this(null, -1);
  }
  public XYAAvatar(Body body) {
    this(body, -1);
  }
  public XYAAvatar(Body body, int frames) {
    this.topBG = new BranchGroup();
    this.topBG.setCapability(BranchGroup.ALLOW_DETACH);
    this.topBG.setCapability(BranchGroup.ALLOW_CHILDREN_READ);
    this.topBG.setCapability(BranchGroup.ALLOW_CHILDREN_WRITE);
    this.topBG.setCapability(BranchGroup.ALLOW_CHILDREN_EXTEND);

    this.geometrySwitchNode = new Switch();
    this.geometrySwitchNode.setCapability(Switch.ALLOW_SWITCH_WRITE);
    this.geometrySwitchNode.setCapability(Switch.ALLOW_CHILDREN_EXTEND);

    this.bottomBG = new BranchGroup();
    this.bottomBG.setCapability(BranchGroup.ALLOW_CHILDREN_READ);
    this.bottomBG.setCapability(BranchGroup.ALLOW_CHILDREN_WRITE);
    this.bottomBG.setCapability(BranchGroup.ALLOW_CHILDREN_EXTEND);

    this.translateTG = new TransformGroup();
    this.translateTG.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
    this.translateTG.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);

    this.rotateTG = new TransformGroup();
    this.rotateTG.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
    this.rotateTG.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
    this.rotateTG.setCapability(TransformGroup.ALLOW_CHILDREN_EXTEND);
    this.rotateTG.setCapability(TransformGroup.ALLOW_CHILDREN_WRITE);

    this.behaviorBG = new BranchGroup();
    this.behaviorBG.setCapability(BranchGroup.ALLOW_CHILDREN_EXTEND);
    this.behaviorBG.setCapability(BranchGroup.ALLOW_DETACH);

    this.topBG.addChild(this.translateTG);
    this.translateTG.addChild(this.rotateTG);
    this.rotateTG.addChild(this.geometrySwitchNode);
    this.rotateTG.addChild(this.bottomBG);

    this.geometryArray = new Array();
    this.appearanceArray = new Array();

    this.t3dTranslation = new Transform3D();
    this.t3dRotation    = new Transform3D();

    this.vectorTranslation = new Vector3d();
    this.vectorRotation = new Vector3d();
    this.matrixRotation = new Matrix3d();

    this.currentAppearanceID = 0;
    this.currentGeometryID  = 0;

    if ((frames >= 0) && (body!=null)){
      setBody(body, frames);
    } else {
      setBody(body);
    }
  }


  /**
   *  Set the appearance corresponding to appearanceID as the new appearance
   *  @param appearanceID the new appearanceID
   */
  public void setAppearanceID(int appearanceID) {

    if (this.appearanceArray.size() > appearanceID) {
      this.currentAppearanceID = appearanceID;
      setShape();
    }
    else {
      System.err.println("AvatarImplBase.setAppearanceID(int) :-> appearanceID too large !!!");
    }
  }

  /**
   *  Set the geometry corresponding to geometryID as the new geometry
   *  @param geometryID ID corresponding to the new geometry
   */
  public void setGeometryID(int geometryID)  {
    if (this.geometryArray.size() > geometryID) {
      this.currentGeometryID = geometryID; // wat is nieuwe geometryID
      setShape();
    }
    else {
      System.err.println("AvatarImplBase.setGeometryID(int) :-> geometryID too large !!!");
    }
  }

  /**
   * Add a geometry to the list of geometry's this avatar can assume
   * @param geometry the new geometry
   */
  public void addGeometry(BaseGeometry geometry) {
    this.geometryArray.add(geometry);
    this.geometrySwitchNode.addChild(geometry.getBG() ); // voeg geometry toe aan array
  }

  /**
   *  Add a geometry to the array of geometry's
   *  @param node the newly to be added geometry
   */
  public void addGeometry(Node node) {
    if (this.geometrySwitchNode.numChildren() == 0) {
      this.geometrySwitchNode.addChild(node);
      this.geometrySwitchNode.setWhichChild(Switch.CHILD_ALL);
    }
    else
      System.err.println("DEBUG method, only one geometry !!!!");
  }

  /**
   * Add a new appearance to the array of appearances
   * @param color the newly to be added appearance
   */
  public void addAppearance(Color3f color) {
    this.appearanceArray.add(color);
  }

  /**
   * Set and show the new geometry and appearance
   */
  protected void setShape() {
    this.currentAppearance = (Color3f)this.appearanceArray.at(this.currentAppearanceID); // wat is de nieuwe kleur
    this.currentGeometry   = (BaseGeometry)this.geometryArray.at(this.currentGeometryID); // wat is nieuwe geometry
    this.currentGeometry.setColor(this.currentAppearance); // geef geometry nieuwe appearance

    this.geometrySwitchNode.setWhichChild(this.currentGeometryID); // maak nieuwe geometry actief
  }

  /**
   * Set the geometry and appearance corresponding to resp. geometryID and appearanceID
   * @param geometryID the ID corresponding to the new geometry
   * @param appearanceID the ID corresponding to the new appearance
   */
  public void setGeometryAndAppearanceID(int geometryID, int appearanceID) {
    // make sure that chosen IDs are always within range
    geometryID = geometryID % geometryArray.size();
    appearanceID = appearanceID % appearanceArray.size();
//    if ((this.geometryArray.size() > geometryID) && (this.appearanceArray.size() > appearanceID)) {
      this.currentGeometryID = geometryID;
      this.currentAppearanceID = appearanceID;
      setShape();
//    }
//    else {
//      System.err.println("AvatarImplBase.setGeometryAndAppearanceID(int, int) :-> one or more ID's too large !!!");
//    }
  }


  private boolean isRefreshCalled = false;
  /**
   * Get the new state from the body and set is in the avatar
   * This method should preferably not be called by the user
   */
  public synchronized void refresh() {
    isRefreshCalled = true;
    synchronized (refreshBehavior) {
      try { refreshBehavior.notify();  }
      catch (Exception e) { e.printStackTrace();  }
    }
  }

  public void refresh(int i) {

  }

  /**
   * Link this avatar with a body
   * @param body the body this avatar is to be linked with
   * @param frames the number of frames between each 'refreshtrigger'
   */
  public void setBody(Body body, int frames) {
    //System.out.println("## setBody!!");
    //if (body!=null) {System.out.println("## and body="+body.toString());} else {System.out.println("but body=null");}
    this.body = body;
    addRefreshBehavior(frames);
  }

  /**
   * Link this avatar with a body
   * @param body the body this avatar is to be linked with
   */
  public void setBody(Body body) {
    this.body = body;
  }

  /**
   * Remove a behavior from the scene, causing it no longer to call refresh
   */
  private void removeRefreshBehavior() {
    this.behaviorBG.detach();
    System.out.println("Just removed RefreshBehavior");
  }

  /**
   * Add refreshbehavior for this avatar to the scene.
   * @param frames the number of frames between each 'trigger'
   */
  private void addRefreshBehavior(int frames) {
    if (!this.behaviorBG.isLive()) {
      //System.out.println("DEBUG -- About to add RefreshBehavior to scene");
      if (this.refreshBehavior == null) {
        //System.out.println("DEBUG -- refreshbehavior = null...so creating");
        this.refreshBehavior = new RefreshBehavior(this, frames);
        this.refreshBehavior.setSchedulingBounds( new BoundingSphere( new Point3d(), 2000.0) );
        this.behaviorBG.addChild(this.refreshBehavior);
        //System.out.println("DEBUG -- RefreshBehavior has just been added to BehaviorBG");
      } // refreshbehavior == null
      this.topBG.addChild(this.behaviorBG);
      //System.out.println("DEBUG -- BehaviorBG has just been added to topBG");
      //
      Thread refreshThread = new Thread() {
        public void run() {
          runForRefreshThread();
        }
      };
      refreshThread.start();
    } // !isLive
    else {
      //System.out.println("DEBUG -- Avatar already has RefreshBehavior!");
    }
  }

  public void runForRefreshThread() {
    for (;;) {
      if (isRefreshCalled) {
        isRefreshCalled = false;

        FuSpace newState = null;
        if (this.body != null) {
          try {
            //System.out.println("Calling getState");
            newState = this.body.getState();
            //if (newState != null) {System.out.println("newState = "+newState.toString());} else {System.out.println("newState = null");}
          } //try
          catch (java.rmi.RemoteException e) {
            System.out.println("RemoteException in XYAAvatar.runForRefreshThread="+e.getMessage() );
            setBody(null); // causes the refresh to be removed
          } //catch
          catch (java.lang.Exception e) {
            System.err.println("Exception in XYAAvatar.runForRefreshThread="+e.getMessage() );
          } //catch
          if (newState != null)
            //System.out.println("calling setState");
            setState(newState);
        } //if body != null
        //else  System.out.println("AvatarImplBase.refresh.....but body=null");

      } else {
        synchronized (refreshBehavior) {
          try { refreshBehavior.wait();  }
          catch (Exception e) { e.printStackTrace();  }
        }
      }
    }
  }

  public void setState(FuSpace state) {
    XYASpace newState=null;
    try{newState = (XYASpace)state;} catch (Exception e) {/*System.out.println("error in setState");*/ return;}

    this.vectorTranslation.set(newState.getX(), newState.getY(), 0);
    this.t3dTranslation.set(this.vectorTranslation);
    this.translateTG.setTransform(this.t3dTranslation);

    this.vectorRotation.set(0, 0, newState.getAlpha());
    this.t3dRotation.setEuler(this.vectorRotation);
    this.rotateTG.setTransform(this.t3dRotation);
  }


  /**
   * set an new shape and its parameters, also update the view.
   * @param geometryId, the geometry-id for this new shape.
   * @param geometryId, the appearance-id for this new shape.
   * @param shape must be a BranchGroup,
   */
  public void setGeometryAndAppearance(int geometryId,int appearanceID, java.rmi.MarshalledObject shape)  {
  }


  /**
   * Remove a child from its parent
   * @param childAvatar the avatar of the child to be orphaned
   */
  public void removeChild(Avatar childAvatar) {
    XYAAvatar child = (XYAAvatar)childAvatar;
    child.getTopBG().detach();
    System.out.println("Avatar.removeChild...just succeeded");
  }

  /**
   * Add another avatar to this avatar.
   * The associated avatar will be a child of this avatar.
   * Therefore its position and orientation will be updated accordingly
   * @param avatar the avatar to be associated with
   */
  public void addChild(Avatar childAvatar) {
    XYAAvatar child = (XYAAvatar)childAvatar;
    this.bottomBG.addChild(child.getTopBG());
    System.out.println("Avatar.addChild...just succeeded");
  }


  /**
   * Set a parent for this child.
   * @param parentAvatar the avatar to be the new parent for this avatar
   */
  public void setParent(Avatar parentAvatar) {
    //if (parentAvatar != null)
    this.topBG.detach();
    XYAAvatar parent = (XYAAvatar)parentAvatar;
    parent.getBottomBG().addChild(this.topBG); // ook meegeven de rel pos van child !!!
  }

  /**
   * Get the top BranchGroup of this avatar
   * @return the top BranchGroup of this avatar
   */
  public BranchGroup getBG() {
    return this.topBG;
  }

  /**
   * Get the top BranchGroup of this avatar
   * @return the top BranchGroup of this avatar
   */
  public BranchGroup getTopBG() {
    return this.topBG;
  }

  /**
   * get the bottom BranchGroup of this avatar
   * @return the bottom most BarnchGroup of this avatar
   */
  public BranchGroup getBottomBG() {
    return this.bottomBG;
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setText(String text) {
    this.currentGeometry.setText(text);
  }
}
