package net.agileframes.traces;

import java.rmi.RemoteException;
import net.jini.core.lookup.ServiceID;
import net.agileframes.server.AgileSystem;
import net.agileframes.server.ServiceProxy;
import net.agileframes.core.forces.MachineRemote;
import net.agileframes.core.server.Server;
import net.agileframes.core.services.Job;
import net.agileframes.core.traces.Actor;
import net.agileframes.core.forces.Manoeuvre;
import net.agileframes.core.traces.SceneAction;
import net.agileframes.core.traces.Actor.NotTrustedException;
import net.agileframes.core.traces.Actor$Properties;
import net.agileframes.core.server.Service;
import net.agileframes.services.ActionJob;
import net.agileframes.server.ServerIB;
import net.agileframes.traces.NavigatorProxy;
import net.jini.core.lookup.ServiceTemplate;

//public class ActorIB extends UnicastRemoteObject implements Remote, Service, Actor, Runnable {
public class ActorIB extends ServerIB implements Actor, Runnable {
  //------------------------------- Attributes -----------------------------
//  private ServiceID actorID = null;    // the serviceID the actor was uploaded with
  private MachineRemote machine = null;
  private SceneAction currentSceneAction = null;
  private SceneAction nextSceneAction = null;
  private Job currentJob = null;
  private Job nextJob = null;
  private boolean shutDown = false;
  private NavigatorProxy navigator = null;
//  private String name;
  //------------------------------- Constructors ---------------------------
  public ActorIB(ServiceID actorID, MachineRemote machine, String name) throws RemoteException {
    super(name, actorID);
    this.machine = machine;
    //this.actorID = actorID;
    //this.name = name;
    Thread jobInterpreterThread = new Thread("JobInterpreterThread@"+name) {
      public void run() { jobInterpreterCycle(); }
    };
    jobInterpreterThread.start();
    this.run();
  }
  //------------------------------- Methods --------------------------------
  // very simple implementation..
  public boolean acceptJob(ServiceID basicServerID, Job job) throws RemoteException, NotTrustedException {
    if (nextJob != null) { return false; }
    if (currentJob == null) { currentJob = job; }
    else { nextJob = job; }
    System.out.println("## "+name+" Accepted a job!");
    synchronized (this) { this.notifyAll(); }
    return true;
  }

  private void downloadNavigator() {
    Class[] navigatorClass = { net.agileframes.traces.NavigatorProxy.class };
    ServiceTemplate navigatorTemplate = new ServiceTemplate(null, navigatorClass, null);
    navigator = (NavigatorProxy)AgileSystem.lookup(navigatorTemplate);
    if (navigator == null) {
      System.out.println("Actor cannot find NavigatorProxy. ");
      System.out.println("The Navigator should have been made available for the JLS.");
    } else { System.out.println("NavigatorProxy has been found."); }
  }

  // Method in which the jobInterpreter-thread cycles. Selects right sceneAction (available under
  // sceneAction and nextSceneAction). jobInterpreterThread is started in constructor.
  protected void jobInterpreterCycle() {//overload this method!
    System.out.println("*** jobInterpreterCycle ***");
    while (!shutDown) {
      while (currentJob == null ) {
        System.out.println("jobInterpreter about to wait for a job");
        try{ synchronized(this) { this.wait(); } }
        catch (Exception e) {
          System.out.println("Exception while waiting in ActorIB.jobInterpreterCycle(): "+e.getMessage());
          e.printStackTrace();
        }
        //System.out.println("jobInterpreterCycle was notified...");
      }
      System.out.println("## jobInterpreter is getting busy!");
      ActionJob actionJob;
      synchronized(this) {
        actionJob = (ActionJob)currentJob;
        currentJob = nextJob;
      }

      if (navigator == null) { downloadNavigator(); }
      if (navigator == null) {
        System.out.println("Actor cannot execute SceneAction, because no Navigator was found");
        break;
      }
      // now let's check if this navigator is still alive or that we should find a new one
      boolean connectable = false;
      while (!connectable) {
        try { connectable = navigator.getLifeSign(); } catch (RemoteException e) {
          // ok, this navigator clearly is not available
          System.out.println ("Downloaded NavigatorProxy is no longer available. Actor needs to download new one.");
          System.out.println ("If  this problem continues to occur, please check your network or restart the Scene.");
          e.printStackTrace();
          try { synchronized(this) { this.wait(5000); } } catch (Exception ex) { ex.printStackTrace(); }
          connectable = false;
        }
      }
      System.out.println("The navigator is responding...");

      currentSceneAction = navigator.getSceneAction(actionJob.getDescription(), this);

      if (currentSceneAction != null) {
        currentSceneAction.setActor(this);
        System.out.println("Downloaded sceneAction :"+currentSceneAction.toString());
      } else {System.out.println("Downloaded sceneAction = null");}

//      currentSceneAction = (SceneAction)actionJob.getSceneAction().clone(this);
//      navigator.getScene();
      /*      try {
      // actor should be made with a reference to an object which contains or 'knows' all available scenes
        CrossScene scene = new CrossScene();// WRONG!! Scene reference should be taken from fixed world somehow
        scene.initialize();
        sceneAction = (SceneAction)scene.leftToRight.clone(this);
      } catch (Exception e) {
        System.out.println("Exception in ActorIB.jobInterpreterCycle: "+e.getMessage());
        e.printStackTrace();
      }*/
      synchronized(this) { this.notify(); }// to wake up run()
    }
  }

  // Method that executes sceneActions.
  public void run() {
    Thread actorRunCycleThread = new Thread("actorRunCycleThread@"+name){
      public void run() { actorRunCycle(); }
    };
    actorRunCycleThread.start();
  }
  protected void actorRunCycle() {
    System.out.println("*** actorRunCycle ***");
    while (!shutDown) {
      while (currentSceneAction == null) {
        try { synchronized(this) { this.wait(); }}
        catch (Exception e) {
          System.out.println("Exception in ActorIB.actorRunCycle: "+e.getMessage());
          e.printStackTrace();
        }
        //System.out.println("actorRunCycle was notified");
      }
      System.out.println("actorRuncycle about to run scene-action");
      currentSceneAction.run();
      System.out.println("scene-action started running");
      currentSceneAction = null;
    }
  }

  public String getName() { return name; }
  public MachineRemote getMachine() { return machine; }
  public Properties getProperties() {
    PropertiesIB props = new PropertiesIB();
    props.name = name;
    props.origin = "N/A";
    props.destination = "N/A";
    props.nextDestination = "N/A";
    props.busy = 0;
    props.idle = 100;
    props.capacity = 0;
    return props;
  }

  public void dispose() {
    super.dispose();
    if (navigator != null) { navigator.destroySceneAction(this); }
    System.out.println("Actor disposed");
  }

  //-------------------- Inherited from Service --------------------------
  //public Server getServer() { return null; }
  //public void setClient(Object client,ServiceID clientID) {}
  //public void setClient(Object client) {}

  public class PropertiesIB implements Properties, java.io.Serializable {
    public String name;
    public String origin;
    public String destination;
    public String nextDestination;
    public double busy;
    public double idle;
    public double capacity;
    public PropertiesIB() {}
  }
}
