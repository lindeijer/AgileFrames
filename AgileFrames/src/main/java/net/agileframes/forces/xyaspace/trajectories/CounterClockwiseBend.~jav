package net.agileframes.forces.xyaspace.trajectories;
import net.agileframes.core.forces.FuTrajectory;
import net.agileframes.core.forces.FuSpace;
import net.agileframes.forces.xyaspace.XYASpace;
import net.agileframes.forces.xyaspace.XYATransform;

public class CounterClockwiseBend extends FuTrajectory {
  private double radius = Double.NaN;
  private double endAngle = Double.NaN;

  public CounterClockwiseBend(double radius, double endAngle, XYATransform transform) {
    this.radius = radius;
    this.endAngle = endAngle;
    this.transform = transform;
    this.evolutionEnd = radius * endAngle;
    this.pilotAlpha = radius / 5;
    this.pilotBeta = 2.5;

    double endX = radius * Math.sin(endAngle);//radius * (1 - Math.cos(endAngle));
    double endY = radius * (1 - Math.cos(endAngle));//radius * Math.sin(endAngle);
    double endA = endAngle;
//actually:    endPoint = ownTransform.transform(new XYASpace(0,0,0));
    FuSpace endPoint = new XYASpace(endX, endY, endA);
    double extX = endX + Math.cos(endAngle);
    double extY = endY + Math.sin(endAngle);
    double extA = endA;
    extension = endPoint.createConnectionPath(new XYASpace(extX, extY, extA));
  }

  public FuSpace getTrajectPoint(double u) {
    if (u > evolutionEnd) { return transform.transform( extension.getConnectionPoint(u - evolutionEnd) ); }
    double x = radius * Math.sin(u / radius);
    double y = radius - radius * Math.cos(u / radius);
    double alpha = u / radius;

    return transform.transform(new XYASpace(x, y, alpha));
  }

  public double getProfileSpeed(double u) {
    if (u > evolutionEnd) { return 0; }
    if (u < 0.7*evolutionEnd) { return 0.8; }
    return 1;
  }
}
