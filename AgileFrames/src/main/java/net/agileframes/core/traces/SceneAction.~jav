package net.agileframes.core.traces;
import net.agileframes.core.forces.Move;
import net.agileframes.core.traces.Actor;
import net.agileframes.core.forces.Sign;
import net.agileframes.core.traces.Ticket;
import net.agileframes.core.traces.Scene;
import net.agileframes.core.traces.BlockException;

import net.agileframes.traces.ActionIB;

import java.rmi.RemoteException;

import com.objectspace.jgl.Array;
import java.io.Serializable;

public abstract class SceneAction extends ActionIB implements Cloneable, Serializable {
  //------------------ Attributes ---------------------
  protected Move[] moves;    // to be defined in the specific SAs, created in initializer
  protected Ticket[] tickets;// to be defined in the specific SAs, created in initializer
  public Scene scene = null;
  protected Action superSceneAction = null;
  public Actor actor = null;

  //------------------ Constructor --------------------
  public SceneAction() throws RemoteException{}
  public SceneAction(Scene scene, Action superSceneAction) throws RemoteException{
    this.scene = scene;
    this.superSceneAction = superSceneAction;
  }

  //------------------ Methods ------------------------
  protected abstract void sceneActionScript() throws BlockException,RemoteException;
  public void run(){
    setState(EXECUTING);// should be RUNNING
    Thread scriptThread = new Thread("SceneActionScriptThread@"+this.toString()){
      public void run() {
        try { sceneActionScript(); }
        catch (Exception e) { System.out.println(e.getMessage()); e.printStackTrace(); System.exit(2); }
      }
    };
    scriptThread.start();
    setState(POST_EXEC);
  }

  public void watch(Sign sign){ watch(new Sign[] {sign}); }
  public void watch(Sign[] signs) {
    boolean broadcasted = false;
    for (int i = 0; i < signs.length; i++) {
      signs[i].addListener(this);
      if (!broadcasted) { broadcasted = signs[i].isBroadcasted();}
    }
    while (!broadcasted) {
      try{ synchronized(this) { this.wait();  }  }
      catch (Exception e) {
        System.out.println("Exception in SceneAction.watch():"+e.getMessage());
        e.printStackTrace();
      }
      for (int i = 0; i < signs.length; i++) { if (!broadcasted) { broadcasted = signs[i].isBroadcasted();} }
    }
  }

  public void startAction(){
  }

  private Array ticketList = new Array();
  public void addTicket(Ticket ticket) {
    ticketList.pushBack(ticket);
    modelChanged();
  }
  public void removeTicket(Ticket ticket) {
    ticketList.remove(ticket);
    ticketList.trimToSize();
    modelChanged();
  }
  protected abstract void modelChanged();


  // should be used to create specific tickets and moves
  protected void initialize() {}

  public Object clone() throws CloneNotSupportedException{
    System.out.println("Cloning SceneAction "+this.toString());
    SceneAction clone = (SceneAction)super.clone();
    if (moves != null) {
      clone.moves = new Move[moves.length];
      for (int i = 0; i < moves.length; i++ ) {  clone.moves[i] = (Move)moves[i].clone();   }
    }
    return clone;
  }

  public void setActor(Actor actor) {
    this.actor = actor;
      for (int i = 0; i < moves.length; i++ ) {  moves[i].setActor(actor);   }
  }

  public void dispose() {
    System.out.println(this.toString()+" disposed");
    if (tickets != null) { for (int i = 0; i < tickets.length; i++ ) {
      try { tickets[i].free(); }
      catch (Exception e) {
        System.out.println("Exception in SceneAction.dispose() while freeing tickets: "+ e.getMessage());
        e.printStackTrace();
        System.out.println("Exception ignored. ");
      }
    }}
  }
}
